<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - post processing - Outline Pass</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<script src="../build/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/DragControls.js"></script>
<script src="js/loaders/OBJLoader.js"></script>
<script src="js/loaders/GLTFLoader.js"></script>

<script src="js/WebGL.js"></script>

<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/OutlinePass.js"></script>
<script src='js/libs/dat.gui.min.js'></script>

<script type="text/javascript" src="../../js/jquery-3.4.1.js"></script>


<script>

  if (WEBGL.isWebGLAvailable() === false) {

    document.body.appendChild(WEBGL.getWebGLErrorMessage());

  }


  var objects = [];

  var container, stats;
  var camera, scene, renderer, controls;
  var raycaster = new THREE.Raycaster();

  var mouse = new THREE.Vector2();
  var selectedObjects = [];

  var composer, outlinePass;
  var obj3d = new THREE.Object3D();

  var group = new THREE.Group();


  $(document).ready(function () {
    init();
    animate();
  });

  function init() {

    container = document.createElement('div');
    document.body.appendChild(container);

    var width = window.innerWidth;
    var height = window.innerHeight;

    renderer = new THREE.WebGLRenderer();
    renderer.shadowMap.enabled = true;
    // todo - support pixelRatio in this demo
    renderer.setSize(width, height);
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();

    const fov = 45;
    const aspect = window.innerWidth / window.innerHeight; //2;  // the canvas default
    const near = 1; //1
    const far = 10000; //200000
    camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(30, 75, 60);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.maxDistance = 5000; // Set our max zoom out distance (mouse scroll)
    controls.minDistance = 3; // Set our min zoom in distance (mouse scroll)
    // controls.enablePan = false;
    // controls.enableDamping = true;
    // controls.dampingFactor = 0.25;

    //

    scene.add(new THREE.AmbientLight(0xaaaaaa, 0.2));

    var light = new THREE.DirectionalLight(0xddffdd, 0.6);
    light.position.set(1, 1, 1);

    light.castShadow = true;

    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;

    var d = 10;

    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.far = 1000;

    scene.add(light);

    // model

    scene.add(group);

    //

    var urls = ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'];
    var loaderCube = new THREE.CubeTextureLoader().setPath('textures/cube/skyboxsun25deg/');
    loaderCube.load(urls, function (texture) {
      scene.background = texture;
    });


    var geometry = new THREE.SphereBufferGeometry(3, 48, 24);

    for (var i = 0; i < 20; i++) {

      var material = new THREE.MeshLambertMaterial();
      material.color.setHSL(Math.random(), 1.0, 0.3);

      var mesh = new THREE.Mesh(geometry, material);
      mesh.position.x = Math.random() * 4 - 2;
      mesh.position.y = Math.random() * 4 - 2;
      mesh.position.z = Math.random() * 4 - 2;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      mesh.scale.multiplyScalar(Math.random() * 0.3 + 0.1);
      group.add(mesh);
      objects.push(mesh);

    }

    var floorMaterial = new THREE.MeshLambertMaterial({side: THREE.DoubleSide});

    var floorGeometry = new THREE.PlaneBufferGeometry(12, 12);
    var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x -= Math.PI * 0.5;
    floorMesh.position.y -= 1.5;
    group.add(floorMesh);
    floorMesh.receiveShadow = true;

    var geometry = new THREE.TorusBufferGeometry(1, 0.3, 16, 100);
    var material = new THREE.MeshPhongMaterial({color: 0xffaaff});
    var torus = new THREE.Mesh(geometry, material);
    torus.position.z = -4;
    group.add(torus);
    objects.push(torus);
    torus.receiveShadow = true;
    torus.castShadow = true;

    //

    // postprocessing

    composer = new THREE.EffectComposer(renderer);

    var renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
    composer.addPass(outlinePass);


    window.addEventListener('resize', onWindowResize, false);

    window.addEventListener('mousemove', onTouchMove);
    window.addEventListener('touchmove', onTouchMove);



    var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
    dragControls.addEventListener('dragstart', function () {
      controls.enabled = false;
    });


    dragControls.addEventListener('dragend', function (object) {
      console.log(object);
//    object.position.y=0;
      controls.enabled = true;
    });


  }

  function onTouchMove(event) {

    var x, y;

    if (event.changedTouches) {

      x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;

    }
    else {

      x = event.clientX;
      y = event.clientY;

    }

    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;

    checkIntersection();

  }

  function addSelectedObject(object) {

    selectedObjects = [];
    selectedObjects.push(object);

  }


  function checkIntersection() {

    raycaster.setFromCamera(mouse, camera);

    var intersects = raycaster.intersectObjects(objects, true);

    if (intersects.length > 0) {

      var selectedObject = intersects[0].object;
      addSelectedObject(selectedObject);
      outlinePass.selectedObjects = selectedObjects;
      console.log(selectedObject);

    }
    else {

      // outlinePass.selectedObjects = [];

    }

  }

  function onWindowResize() {

    var width = window.innerWidth;
    var height = window.innerHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
    composer.setSize(width, height);


  }

  function animate() {

    requestAnimationFrame(animate);


    var timer = performance.now();

    // if ( params.rotate ) {
    //
    // 	group.rotation.y = timer * 0.0001;
    //
    // }

    controls.update();

    composer.render();


  }

</script>
</body>
</html>
